# â€˜ì½˜ì„œíŠ¸ ì˜ˆì•½ ì„œë¹„ìŠ¤â€™ ì‹œë‚˜ë¦¬ì˜¤ ê¸°ë°˜## ğŸ¯ Redis ê¸°ë°˜ ìºì‹± ì „ëµ ì„±ëŠ¥ ê°œì„ ## 1. ëª©ì ëŒ€ìš©ëŸ‰ íŠ¸ë˜í”½ ìƒí™©ì—ì„œ **DB ë¶€í•˜ ë¶„ì‚°**ê³¼ **í•µì‹¬ ë°ì´í„°ì˜ ì‘ë‹µ ì†ë„ ê°œì„ **ì„ ìœ„í•´ Redisë¥¼ ë„ì…í•˜ì—¬, ìì£¼ ì¡°íšŒë˜ëŠ” **ì½˜ì„œíŠ¸/ìŠ¤ì¼€ì¤„ ì •ë³´**ì™€ **ì˜ˆì•½ ê²°ê³¼**ë¥¼ ìºì‹±í•˜ì˜€ë‹¤.## 2. Redis ìºì‹± ì „ëµ| ìºì‹± ëŒ€ìƒ | ìºì‹œ í‚¤ | ìºì‹œ ì–´ë…¸í…Œì´ì…˜ | TTL || --- | --- | --- | --- || ì½˜ì„œíŠ¸ ì¡°íšŒ | **concert::{id}** | `@Cacheable` | 5ë¶„ || ì½˜ì„œíŠ¸ ìŠ¤ì¼€ì¤„ ì¡°íšŒ | **concertSchedule::{concertId}:{yyyy-MM-dd}** | `@Cacheable` | 5ë¶„ || ì½˜ì„œíŠ¸ ì˜ˆì•½  | **reservation::{userId}:{concertScheduleId}:{seatNumber}** | `@CachePut` | 5ë¶„ || ì½˜ì„œíŠ¸ ì˜ˆì•½ ì¡°íšŒ | **reservation::{reservationId}** | `@Cacheable` | 5ë¶„ |## 3. Redis ì„¤ì •### âœ… `RedisCacheManager` ì„¤ì •```java@Beanpublic RedisCacheManager cacheManager(RedisConnectionFactory redisConnectionFactory) {    ObjectMapper objectMapper = new ObjectMapper();    objectMapper.registerModule(new JavaTimeModule()); // LocalDateTime ì§ë ¬í™” ì§€ì›    objectMapper.disable(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS); // ë‚ ì§œë¥¼ íƒ€ì„ìŠ¤íƒ¬í”„ ëŒ€ì‹  ISO-8601 í˜•ì‹ ì‚¬ìš©    objectMapper.activateDefaultTyping( // ì§ë ¬í™” ì‹œ íƒ€ì… ì •ë³´ í¬í•¨        LaissezFaireSubTypeValidator.instance,        ObjectMapper.DefaultTyping.NON_FINAL,        JsonTypeInfo.As.PROPERTY    );    GenericJackson2JsonRedisSerializer serializer = new GenericJackson2JsonRedisSerializer(objectMapper);    RedisCacheConfiguration config = RedisCacheConfiguration.defaultCacheConfig()        .entryTtl(Duration.ofMinutes(5)) // TTL: 5ë¶„        .serializeKeysWith(RedisSerializationContext.SerializationPair.fromSerializer(new StringRedisSerializer()))        .serializeValuesWith(RedisSerializationContext.SerializationPair.fromSerializer(serializer));    return RedisCacheManager.builder(redisConnectionFactory)        .cacheDefaults(config)        .build();}```### âœ… `RedisTemplate` ì„¤ì •```java@Beanpublic RedisTemplate<String, Object> redisTemplate(RedisConnectionFactory connectionFactory) {    ObjectMapper objectMapper = new ObjectMapper();    objectMapper.registerModule(new JavaTimeModule());    objectMapper.disable(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS);    objectMapper.activateDefaultTyping(        LaissezFaireSubTypeValidator.instance,        ObjectMapper.DefaultTyping.NON_FINAL,        JsonTypeInfo.As.PROPERTY    );    GenericJackson2JsonRedisSerializer serializer = new GenericJackson2JsonRedisSerializer(objectMapper);    RedisTemplate<String, Object> template = new RedisTemplate<>();    template.setConnectionFactory(connectionFactory);    template.setKeySerializer(new StringRedisSerializer());    template.setValueSerializer(serializer); // valueì— JSON ì§ë ¬í™” ì ìš©    template.setHashKeySerializer(new StringRedisSerializer());    template.setHashValueSerializer(serializer);    return template;}```- `GenericJackson2JsonRedisSerializer`: ë‹¤ì–‘í•œ í´ë˜ìŠ¤ì˜ ê°ì²´ë¥¼ Redisì— JSONìœ¼ë¡œ ì§ë ¬í™”/ì—­ì§ë ¬í™” ê°€ëŠ¥í•˜ê²Œ í•œë‹¤.- `activateDefaultTyping`: ëª¨ë“  ì§ë ¬í™”ë˜ëŠ” ê°ì²´ì— `@class` ì •ë³´ë¥¼ ìë™ìœ¼ë¡œ ë¶™ì—¬ì¤€ë‹¤.    - `@Cacheable`ì€ ìºì‹±ëœ ê°ì²´ë¥¼ ì €ì¥í•˜ê³  ë³µì›í•  ë•Œ ì§ë ¬í™”/ì—­ì§ë ¬í™”ë¥¼ ìˆ˜í–‰í•˜ëŠ”ë°, ë‹¤ì–‘í•œ ë„ë©”ì¸ ê°ì²´ë“¤ì€ ëª¨ë‘ êµ¬ì¡°ê°€ ë‹¤ë¥´ê¸°ì— ì—­ì§ë ¬í™” ì‹œ ì •í™•í•œ í´ë˜ìŠ¤ ì •ë³´ê°€ í•„ìš”    - `@JsonTypeInfo` ìœ¼ë¡œ ì§ì ‘ ëª…ì‹œ ë°©ë²•ë„ ì¡´ì¬ â†’  íƒ€ì…ì´ record ì˜ ê²½ìš°- **TTL ì„¤ì •**: 5ë¶„ í›„ ìºì‹œ ìë™ ë§Œë£Œì‹œí‚¤ê³  ìµœì‹  ë°ì´í„° ìœ ì§€í•  ìˆ˜ ìˆê²Œ í•œë‹¤.## ğŸ”„ ì§ë ¬í™”(Serialization) **ì—­ì§ë ¬í™”(Deserialization)**ë€?ê°ì²´ëŠ” ë‚´ë¶€ì ìœ¼ë¡œ ë‹¤ì–‘í•œ ê°’ê³¼ íƒ€ì…ì„ ê°€ì§€ê³  ìˆì§€ë§Œ RedisëŠ” ë‹¨ìˆœí•œ ë¬¸ìì—´ì´ë‚˜ ë°”ì´íŠ¸ë§Œ ì €ì¥í•  ìˆ˜ ìˆê¸°ì— ì´ ê°ì²´ë¥¼ Redisì— ì €ì¥í•˜ë ¤ë©´ ë¬¸ìì—´(JSON ë“±)ë¡œ ë°”ê¾¸ëŠ” ê²ƒì„ **ì§ë ¬í™”**ê·¸ ë°˜ëŒ€ë¡œ, Redisì—ì„œ ë‹¤ì‹œ ê·¸ ê°ì²´ë¥¼ êº¼ë‚¼ ë•ŒëŠ”, ì €ì¥ëœ ë¬¸ìì—´(JSON)ì„ ë‹¤ì‹œ ê°ì²´ë¡œ ë³µì›í•˜ëŠ”ê²ƒì„ **ì—­ì§ë ¬í™”**---## 4. ê¸°ëŠ¥ ë° ì„±ëŠ¥ í…ŒìŠ¤íŠ¸- ì½˜ì„œíŠ¸ ë° ì½˜ì„œíŠ¸ ìŠ¤ì¼€ì¤„ ì¡°íšŒ ìºì‹±ì˜ ê²½ìš° 1ì°¨ ì¡°íšŒ ì‹œ DBë¡œ, 2ì°¨ ì¡°íšŒ ì‹œì—ëŠ” ìºì‹œë¥¼ ì‚¬ìš©í•˜ì—¬ ìºì‹œ í‚¤ì˜ ìƒì„± ìœ ë¬´ë¥¼ Junitê³¼ redis-cli ë¡œ keyë¥¼ ì¡°íšŒí•˜ì—¬ í™•ì¸í•˜ì˜€ë‹¤.```java@Test    void canSelectCachedConcert() {        // given        Long concertId = 1L;        String cacheKey = "concert::" + concertId;        // when        // 1ì°¨ ì¡°íšŒ (DB ì ‘ê·¼)        Concert concert = concertService.findConcertById(concertId);        // 2ì°¨ ì¡°íšŒ (ìºì‹œ ì‚¬ìš©)        Concert cachedConcert = concertService.findConcertById(concertId);        // then        assertNotNull(concert);        assertNotNull(cachedConcert);        System.out.println("Redis í‚¤ :" + cacheKey);        Boolean hasKey = redisTemplate.hasKey(cacheKey);        assertTrue(hasKey);    }    @Test    void canSelectCachedConcertSchedule() {        // given        Long concertId = 1L;        LocalDateTime scheduleDate = LocalDateTime.of(2025, 5, 5, 20, 0,0);        String cacheKey = "concertSchedule::" + concertId + ":" + scheduleDate.toLocalDate();        // when        // 1ì°¨ ì¡°íšŒ (DB ì ‘ê·¼)        ConcertSchedule schedule = concertScheduleService.findConcertSchedulesByIdAndDate(concertId, scheduleDate);        // 2ì°¨ ì¡°íšŒ (ìºì‹œ ì‚¬ìš©)        ConcertSchedule cachedSchedule = concertScheduleService.findConcertSchedulesByIdAndDate(concertId, scheduleDate);        // then        assertNotNull(schedule);        assertNotNull(cachedSchedule);        System.out.println("Redis í‚¤ : " + cacheKey);        Boolean hasKey = redisTemplate.hasKey(cacheKey);        assertTrue(hasKey);    }```- ì˜ˆì•½ì‹œ í•´ë‹¹ ì˜ˆì•½ ì •ë³´ë¥¼ í‚¤ë¡œ ìƒì„± í›„ì— ìºì‹±ëœ í‚¤ë¥¼ Junitê³¼ redis-cli ë¡œ í™•ì¸ í›„, í•´ë‹¹ í‚¤ë¡œ ê²°ì œì‹œì— ê²°ì œê°€ ì •ìƒì ìœ¼ë¡œ ì´ë£¨ì–´ ì§€ëŠ”ì§€ í…ŒìŠ¤íŠ¸í•˜ì˜€ë‹¤.```java @Test    void makeReservation_And_PayByCachedReservation() {        // given        Long userId = 2L;        Long concertScheduleId = 2L;        Long seatNumber = 2L;        ReservationCommand command = new ReservationCommand(userId, concertScheduleId, seatNumber);        // when (ì˜ˆì•½)        ReservationResult result = reservationFacade.makeReservation(command);        Long reservationId = result.id();        // then (ì˜ˆì•½ ë ˆë””ìŠ¤ í‚¤ í™•ì¸)        String cacheKeyPrefix = "reservation::";        String compositeKey = userId + ":" + concertScheduleId + ":" + seatNumber;        System.out.println("reservation key: " + cacheKeyPrefix + compositeKey);        Object cachedReservation = redisTemplate.opsForValue().get(cacheKeyPrefix + compositeKey);        assertThat(cachedReservation).isNotNull();        assertThat(((Reservation) cachedReservation).getId()).isEqualTo(reservationId);        // when (í•´ë‹¹ í‚¤ë¡œ ê²°ì œ)        Wallet wallet = walletFacade.wallet(userId, reservationId);        // then (ê²°ì œ í™•ì¸)        assertThat(wallet).isNotNull();        assertThat(wallet.getUserId()).isEqualTo(userId);    }```---- ì½˜ì„œíŠ¸ ì¡°íšŒì‹œ DB ì™€ Cache ë¥¼ ë¹„êµí•˜ì—¬ ì„±ëŠ¥ í…ŒìŠ¤íŠ¸ë¥¼ í•˜ì˜€ë‹¤.```java@Test    void performanceConcertCache() {        // given        Long concertId = 1L;        int iterations = 100;        long dbAccessTime = 0;        long cacheAccessTime = 0;        // when         // DB ì ‘ê·¼ ì‹œê°„ ì¸¡ì • (ìºì‹œë¥¼ ë¹„ì›Œê°€ë©° ë°˜ë³µ í…ŒìŠ¤íŠ¸)        for (int i = 0; i < iterations; i++) {            // ë§¤ ë°˜ë³µë§ˆë‹¤ ìºì‹œ ì´ˆê¸°í™”            redisTemplate.getConnectionFactory().getConnection().flushAll();            long startTime = System.nanoTime();            concertService.findConcertById(concertId);            long endTime = System.nanoTime();            dbAccessTime += (endTime - startTime);        }        // when         // cache ì ‘ê·¼ ì‹œê°„ ì¸¡ì •        for (int i = 0; i < iterations; i++) {            long startTime = System.nanoTime();            concertService.findConcertById(concertId);            long endTime = System.nanoTime();            cacheAccessTime += (endTime - startTime);        }        // then        double dbAvgTime = dbAccessTime / (double) iterations / 1_000_000.0;         double cacheAvgTime = cacheAccessTime / (double) iterations / 1_000_000.0;        double speedup = dbAvgTime / cacheAvgTime;        System.out.println("===== Concert ìºì‹œ ì„±ëŠ¥ í…ŒìŠ¤íŠ¸ ê²°ê³¼ =====");        System.out.println("DB ì ‘ê·¼ í‰ê·  ì‹œê°„: " + dbAvgTime + " ms");        System.out.println("ìºì‹œ ì ‘ê·¼ í‰ê·  ì‹œê°„: " + cacheAvgTime + " ms");        System.out.println("ì„±ëŠ¥ í–¥ìƒ ë¹„ìœ¨: " + speedup + "ë°°");        // then        assertTrue(cacheAvgTime < dbAvgTime);    }```- ë©€í‹°ìŠ¤ë ˆë“œì˜ ê²½ìš°ì—ë„ ë™ì¼í•˜ê²Œ í…ŒìŠ¤íŠ¸ë¥¼ ì§„í–‰í•˜ì˜€ë‹¤.    ```java    @Test        void multiThreadCaching_PerformanceConcertCache() throws InterruptedException {            // given            Long concertId = 1L;            int threadCount = 20;            int requestsPerThread = 50;            CountDownLatch latch = new CountDownLatch(threadCount);                AtomicLong totalTimeWithoutCache = new AtomicLong(0);            AtomicLong totalTimeWithCache = new AtomicLong(0);                // when (ìºì‹œ ì—†ì´ ì¡°íšŒ)            redisTemplate.getConnectionFactory().getConnection().flushAll();                List<Thread> threadsWithoutCache = new ArrayList<>();            for (int i = 0; i < threadCount; i++) {                Thread t = new Thread(() -> {                    try {                        long threadTime = 0;                        for (int j = 0; j < requestsPerThread; j++) {                            redisTemplate.getConnectionFactory().getConnection().flushAll();                            long startTime = System.nanoTime();                            concertService.findConcertById(concertId);                            long endTime = System.nanoTime();                            threadTime += (endTime - startTime);                        }                        totalTimeWithoutCache.addAndGet(threadTime);                    } finally {                        latch.countDown();                    }                });                threadsWithoutCache.add(t);                t.start();            }                latch.await();                // when (ìºì‹œ ì‚¬ìš© ì¡°íšŒ)            CountDownLatch latch2 = new CountDownLatch(threadCount);                List<Thread> threadsWithCache = new ArrayList<>();            for (int i = 0; i < threadCount; i++) {                Thread t = new Thread(() -> {                    try {                        long threadTime = 0;                        for (int j = 0; j < requestsPerThread; j++) {                            long startTime = System.nanoTime();                            concertService.findConcertById(concertId);                            long endTime = System.nanoTime();                            threadTime += (endTime - startTime);                        }                        totalTimeWithCache.addAndGet(threadTime);                    } finally {                        latch2.countDown();                    }                });                threadsWithCache.add(t);                t.start();            }                latch2.await();                // then            double avgTimeWithoutCache = totalTimeWithoutCache.get() / (double) (threadCount * requestsPerThread) / 1_000_000.0;            double avgTimeWithCache = totalTimeWithCache.get() / (double) (threadCount * requestsPerThread) / 1_000_000.0;            double speedup = avgTimeWithoutCache / avgTimeWithCache;                System.out.println("===== ìºì‹œ ì„±ëŠ¥ í…ŒìŠ¤íŠ¸ ê²°ê³¼ =====");            System.out.println("ìŠ¤ë ˆë“œ ìˆ˜: " + threadCount + ", ìŠ¤ë ˆë“œë‹¹ ìš”ì²­ ìˆ˜: " + requestsPerThread);            System.out.println("ìºì‹œ ì—†ì´ í‰ê·  ì‹œê°„: " + avgTimeWithoutCache + " ms");            System.out.println("ìºì‹œ ì‚¬ìš© í‰ê·  ì‹œê°„: " + avgTimeWithCache + " ms");            System.out.println("ì„±ëŠ¥ í–¥ìƒ ë¹„ìœ¨: " + speedup + "ë°°");                // then            assertTrue(avgTimeWithCache < avgTimeWithoutCache);        }    ```