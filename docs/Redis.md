# ‘콘서트 예약 서비스’ 시나리오 기반## 🎯 Redis 기반 캐싱 전략 성능 개선## 1. 목적대용량 트래픽 상황에서 **DB 부하 분산**과 **핵심 데이터의 응답 속도 개선**을 위해 Redis를 도입하여, 자주 조회되는 **콘서트/스케줄 정보**와 **예약 결과**를 캐싱하였다.## 2. Redis 캐싱 전략| 캐싱 대상 | 캐시 키 | 캐시 어노테이션 | TTL || --- | --- | --- | --- || 콘서트 조회 | **concert::{id}** | `@Cacheable` | 5분 || 콘서트 스케줄 조회 | **concertSchedule::{concertId}:{yyyy-MM-dd}** | `@Cacheable` | 5분 || 콘서트 예약  | **reservation::{userId}:{concertScheduleId}:{seatNumber}** | `@CachePut` | 5분 || 콘서트 예약 조회 | **reservation::{reservationId}** | `@Cacheable` | 5분 |## 3. Redis 설정### ✅ `RedisCacheManager` 설정```java@Beanpublic RedisCacheManager cacheManager(RedisConnectionFactory redisConnectionFactory) {    ObjectMapper objectMapper = new ObjectMapper();    objectMapper.registerModule(new JavaTimeModule()); // LocalDateTime 직렬화 지원    objectMapper.disable(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS); // 날짜를 타임스탬프 대신 ISO-8601 형식 사용    objectMapper.activateDefaultTyping( // 직렬화 시 타입 정보 포함        LaissezFaireSubTypeValidator.instance,        ObjectMapper.DefaultTyping.NON_FINAL,        JsonTypeInfo.As.PROPERTY    );    GenericJackson2JsonRedisSerializer serializer = new GenericJackson2JsonRedisSerializer(objectMapper);    RedisCacheConfiguration config = RedisCacheConfiguration.defaultCacheConfig()        .entryTtl(Duration.ofMinutes(5)) // TTL: 5분        .serializeKeysWith(RedisSerializationContext.SerializationPair.fromSerializer(new StringRedisSerializer()))        .serializeValuesWith(RedisSerializationContext.SerializationPair.fromSerializer(serializer));    return RedisCacheManager.builder(redisConnectionFactory)        .cacheDefaults(config)        .build();}```### ✅ `RedisTemplate` 설정```java@Beanpublic RedisTemplate<String, Object> redisTemplate(RedisConnectionFactory connectionFactory) {    ObjectMapper objectMapper = new ObjectMapper();    objectMapper.registerModule(new JavaTimeModule());    objectMapper.disable(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS);    objectMapper.activateDefaultTyping(        LaissezFaireSubTypeValidator.instance,        ObjectMapper.DefaultTyping.NON_FINAL,        JsonTypeInfo.As.PROPERTY    );    GenericJackson2JsonRedisSerializer serializer = new GenericJackson2JsonRedisSerializer(objectMapper);    RedisTemplate<String, Object> template = new RedisTemplate<>();    template.setConnectionFactory(connectionFactory);    template.setKeySerializer(new StringRedisSerializer());    template.setValueSerializer(serializer); // value에 JSON 직렬화 적용    template.setHashKeySerializer(new StringRedisSerializer());    template.setHashValueSerializer(serializer);    return template;}```- `GenericJackson2JsonRedisSerializer`: 다양한 클래스의 객체를 Redis에 JSON으로 직렬화/역직렬화 가능하게 한다.- `activateDefaultTyping`: 모든 직렬화되는 객체에 `@class` 정보를 자동으로 붙여준다.    - `@Cacheable`은 캐싱된 객체를 저장하고 복원할 때 직렬화/역직렬화를 수행하는데, 다양한 도메인 객체들은 모두 구조가 다르기에 역직렬화 시 정확한 클래스 정보가 필요    - `@JsonTypeInfo` 으로 직접 명시 방법도 존재 →  타입이 record 의 경우- **TTL 설정**: 5분 후 캐시 자동 만료시키고 최신 데이터 유지할 수 있게 한다.## 🔄 직렬화(Serialization) **역직렬화(Deserialization)**란?객체는 내부적으로 다양한 값과 타입을 가지고 있지만 Redis는 단순한 문자열이나 바이트만 저장할 수 있기에 이 객체를 Redis에 저장하려면 문자열(JSON 등)로 바꾸는 것을 **직렬화**그 반대로, Redis에서 다시 그 객체를 꺼낼 때는, 저장된 문자열(JSON)을 다시 객체로 복원하는것을 **역직렬화**---## 4. 기능 및 성능 테스트- 콘서트 및 콘서트 스케줄 조회 캐싱의 경우 1차 조회 시 DB로, 2차 조회 시에는 캐시를 사용하여 캐시 키의 생성 유무를 Junit과 redis-cli 로 key를 조회하여 확인하였다.```java@Test    void canSelectCachedConcert() {        // given        Long concertId = 1L;        String cacheKey = "concert::" + concertId;        // when        // 1차 조회 (DB 접근)        Concert concert = concertService.findConcertById(concertId);        // 2차 조회 (캐시 사용)        Concert cachedConcert = concertService.findConcertById(concertId);        // then        assertNotNull(concert);        assertNotNull(cachedConcert);        System.out.println("Redis 키 :" + cacheKey);        Boolean hasKey = redisTemplate.hasKey(cacheKey);        assertTrue(hasKey);    }    @Test    void canSelectCachedConcertSchedule() {        // given        Long concertId = 1L;        LocalDateTime scheduleDate = LocalDateTime.of(2025, 5, 5, 20, 0,0);        String cacheKey = "concertSchedule::" + concertId + ":" + scheduleDate.toLocalDate();        // when        // 1차 조회 (DB 접근)        ConcertSchedule schedule = concertScheduleService.findConcertSchedulesByIdAndDate(concertId, scheduleDate);        // 2차 조회 (캐시 사용)        ConcertSchedule cachedSchedule = concertScheduleService.findConcertSchedulesByIdAndDate(concertId, scheduleDate);        // then        assertNotNull(schedule);        assertNotNull(cachedSchedule);        System.out.println("Redis 키 : " + cacheKey);        Boolean hasKey = redisTemplate.hasKey(cacheKey);        assertTrue(hasKey);    }```- 예약시 해당 예약 정보를 키로 생성 후에 캐싱된 키를 Junit과 redis-cli 로 확인 후, 해당 키로 결제시에 결제가 정상적으로 이루어 지는지 테스트하였다.```java @Test    void makeReservation_And_PayByCachedReservation() {        // given        Long userId = 2L;        Long concertScheduleId = 2L;        Long seatNumber = 2L;        ReservationCommand command = new ReservationCommand(userId, concertScheduleId, seatNumber);        // when (예약)        ReservationResult result = reservationFacade.makeReservation(command);        Long reservationId = result.id();        // then (예약 레디스 키 확인)        String cacheKeyPrefix = "reservation::";        String compositeKey = userId + ":" + concertScheduleId + ":" + seatNumber;        System.out.println("reservation key: " + cacheKeyPrefix + compositeKey);        Object cachedReservation = redisTemplate.opsForValue().get(cacheKeyPrefix + compositeKey);        assertThat(cachedReservation).isNotNull();        assertThat(((Reservation) cachedReservation).getId()).isEqualTo(reservationId);        // when (해당 키로 결제)        Wallet wallet = walletFacade.wallet(userId, reservationId);        // then (결제 확인)        assertThat(wallet).isNotNull();        assertThat(wallet.getUserId()).isEqualTo(userId);    }```---- 콘서트 조회시 DB 와 Cache 를 비교하여 성능 테스트를 하였다.```java@Test    void performanceConcertCache() {        // given        Long concertId = 1L;        int iterations = 100;        long dbAccessTime = 0;        long cacheAccessTime = 0;        // when         // DB 접근 시간 측정 (캐시를 비워가며 반복 테스트)        for (int i = 0; i < iterations; i++) {            // 매 반복마다 캐시 초기화            redisTemplate.getConnectionFactory().getConnection().flushAll();            long startTime = System.nanoTime();            concertService.findConcertById(concertId);            long endTime = System.nanoTime();            dbAccessTime += (endTime - startTime);        }        // when         // cache 접근 시간 측정        for (int i = 0; i < iterations; i++) {            long startTime = System.nanoTime();            concertService.findConcertById(concertId);            long endTime = System.nanoTime();            cacheAccessTime += (endTime - startTime);        }        // then        double dbAvgTime = dbAccessTime / (double) iterations / 1_000_000.0;         double cacheAvgTime = cacheAccessTime / (double) iterations / 1_000_000.0;        double speedup = dbAvgTime / cacheAvgTime;        System.out.println("===== Concert 캐시 성능 테스트 결과 =====");        System.out.println("DB 접근 평균 시간: " + dbAvgTime + " ms");        System.out.println("캐시 접근 평균 시간: " + cacheAvgTime + " ms");        System.out.println("성능 향상 비율: " + speedup + "배");        // then        assertTrue(cacheAvgTime < dbAvgTime);    }```- 멀티스레드의 경우에도 동일하게 테스트를 진행하였다.    ```java    @Test        void multiThreadCaching_PerformanceConcertCache() throws InterruptedException {            // given            Long concertId = 1L;            int threadCount = 20;            int requestsPerThread = 50;            CountDownLatch latch = new CountDownLatch(threadCount);                AtomicLong totalTimeWithoutCache = new AtomicLong(0);            AtomicLong totalTimeWithCache = new AtomicLong(0);                // when (캐시 없이 조회)            redisTemplate.getConnectionFactory().getConnection().flushAll();                List<Thread> threadsWithoutCache = new ArrayList<>();            for (int i = 0; i < threadCount; i++) {                Thread t = new Thread(() -> {                    try {                        long threadTime = 0;                        for (int j = 0; j < requestsPerThread; j++) {                            redisTemplate.getConnectionFactory().getConnection().flushAll();                            long startTime = System.nanoTime();                            concertService.findConcertById(concertId);                            long endTime = System.nanoTime();                            threadTime += (endTime - startTime);                        }                        totalTimeWithoutCache.addAndGet(threadTime);                    } finally {                        latch.countDown();                    }                });                threadsWithoutCache.add(t);                t.start();            }                latch.await();                // when (캐시 사용 조회)            CountDownLatch latch2 = new CountDownLatch(threadCount);                List<Thread> threadsWithCache = new ArrayList<>();            for (int i = 0; i < threadCount; i++) {                Thread t = new Thread(() -> {                    try {                        long threadTime = 0;                        for (int j = 0; j < requestsPerThread; j++) {                            long startTime = System.nanoTime();                            concertService.findConcertById(concertId);                            long endTime = System.nanoTime();                            threadTime += (endTime - startTime);                        }                        totalTimeWithCache.addAndGet(threadTime);                    } finally {                        latch2.countDown();                    }                });                threadsWithCache.add(t);                t.start();            }                latch2.await();                // then            double avgTimeWithoutCache = totalTimeWithoutCache.get() / (double) (threadCount * requestsPerThread) / 1_000_000.0;            double avgTimeWithCache = totalTimeWithCache.get() / (double) (threadCount * requestsPerThread) / 1_000_000.0;            double speedup = avgTimeWithoutCache / avgTimeWithCache;                System.out.println("===== 캐시 성능 테스트 결과 =====");            System.out.println("스레드 수: " + threadCount + ", 스레드당 요청 수: " + requestsPerThread);            System.out.println("캐시 없이 평균 시간: " + avgTimeWithoutCache + " ms");            System.out.println("캐시 사용 평균 시간: " + avgTimeWithCache + " ms");            System.out.println("성능 향상 비율: " + speedup + "배");                // then            assertTrue(avgTimeWithCache < avgTimeWithoutCache);        }    ```