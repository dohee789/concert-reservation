# ‘콘서트 예약 서비스’ 시나리오 기반## 🎯 Redis 기반 캐싱 전략 성능 개선## 1. 목적대용량 트래픽 상황에서 **DB 부하 분산**과 **핵심 데이터의 응답 속도 개선**을 위해 Redis를 도입하여, 자주 조회되는 **콘서트/스케줄 정보**와 **예약 결과**를 캐싱하였다.## 2. Redis 캐싱 전략| 캐싱 대상 | 캐시 키 | 캐시 어노테이션 | TTL || --- | --- | --- | --- || 콘서트 조회 | **concert::{id}** | `@Cacheable` | 5분 || 콘서트 스케줄 조회 | **concertSchedule::{concertId}:{yyyy-MM-dd}** | `@Cacheable` | 5분 || 콘서트 예약  | **reservation::{userId}:{concertScheduleId}:{seatNumber}** | `@CachePut` | 5분 || 콘서트 예약 조회 | **reservation::{reservationId}** | `@Cacheable` | 5분 |## 3. Redis 설정### ✅ `RedisCacheManager` 설정```java@Beanpublic RedisCacheManager cacheManager(RedisConnectionFactory redisConnectionFactory) {    ObjectMapper objectMapper = new ObjectMapper();    objectMapper.registerModule(new JavaTimeModule()); // LocalDateTime 직렬화 지원    objectMapper.disable(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS); // 날짜를 타임스탬프 대신 ISO-8601 형식 사용    objectMapper.activateDefaultTyping( // 직렬화 시 타입 정보 포함        LaissezFaireSubTypeValidator.instance,        ObjectMapper.DefaultTyping.NON_FINAL,        JsonTypeInfo.As.PROPERTY    );    GenericJackson2JsonRedisSerializer serializer = new GenericJackson2JsonRedisSerializer(objectMapper);    RedisCacheConfiguration config = RedisCacheConfiguration.defaultCacheConfig()        .entryTtl(Duration.ofMinutes(5)) // TTL: 5분        .serializeKeysWith(RedisSerializationContext.SerializationPair.fromSerializer(new StringRedisSerializer()))        .serializeValuesWith(RedisSerializationContext.SerializationPair.fromSerializer(serializer));    return RedisCacheManager.builder(redisConnectionFactory)        .cacheDefaults(config)        .build();}```### ✅ `RedisTemplate` 설정```java@Beanpublic RedisTemplate<String, Object> redisTemplate(RedisConnectionFactory connectionFactory) {    ObjectMapper objectMapper = new ObjectMapper();    objectMapper.registerModule(new JavaTimeModule());    objectMapper.disable(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS);    objectMapper.activateDefaultTyping(        LaissezFaireSubTypeValidator.instance,        ObjectMapper.DefaultTyping.NON_FINAL,        JsonTypeInfo.As.PROPERTY    );    GenericJackson2JsonRedisSerializer serializer = new GenericJackson2JsonRedisSerializer(objectMapper);    RedisTemplate<String, Object> template = new RedisTemplate<>();    template.setConnectionFactory(connectionFactory);    template.setKeySerializer(new StringRedisSerializer());    template.setValueSerializer(serializer); // value에 JSON 직렬화 적용    template.setHashKeySerializer(new StringRedisSerializer());    template.setHashValueSerializer(serializer);    return template;}```- `GenericJackson2JsonRedisSerializer`: 다양한 클래스의 객체를 Redis에 JSON으로 직렬화/역직렬화 가능하게 한다.- `activateDefaultTyping`: 모든 직렬화되는 객체에 `@class` 정보를 자동으로 붙여준다.    - `@Cacheable`은 캐싱된 객체를 저장하고 복원할 때 직렬화/역직렬화를 수행하는데, 다양한 도메인 객체들은 모두 구조가 다르기에 역직렬화 시 정확한 클래스 정보가 필요    - `@JsonTypeInfo` 으로 직접 명시 방법도 존재 →  타입이 record 의 경우- **TTL 설정**: 5분 후 캐시 자동 만료시키고 최신 데이터 유지할 수 있게 한다.## 🔄 직렬화(Serialization) **역직렬화(Deserialization)**란?객체는 내부적으로 다양한 값과 타입을 가지고 있지만 Redis는 단순한 문자열이나 바이트만 저장할 수 있기에 이 객체를 Redis에 저장하려면 문자열(JSON 등)로 바꾸는 것을 **직렬화**그 반대로, Redis에서 다시 그 객체를 꺼낼 때는, 저장된 문자열(JSON)을 다시 객체로 복원하는것을 **역직렬화**---## 4. 기능 및 성능 테스트- 콘서트 및 콘서트 스케줄 조회 캐싱의 경우 1차 조회 시 DB로, 2차 조회 시에는 캐시를 사용하여 캐시 키의 생성 유무를 Junit과 redis-cli 로 key를 조회하여 확인하였다.```java@Test    void canSelectCachedConcert() {        // given        Long concertId = 1L;        String cacheKey = "concert::" + concertId;        // when        // 1차 조회 (DB 접근)        Concert concert = concertService.findConcertById(concertId);        // 2차 조회 (캐시 사용)        Concert cachedConcert = concertService.findConcertById(concertId);        // then        assertNotNull(concert);        assertNotNull(cachedConcert);        System.out.println("Redis 키 :" + cacheKey);        Boolean hasKey = redisTemplate.hasKey(cacheKey);        assertTrue(hasKey);    }    @Test    void canSelectCachedConcertSchedule() {        // given        Long concertId = 1L;        LocalDateTime scheduleDate = LocalDateTime.of(2025, 5, 5, 20, 0,0);        String cacheKey = "concertSchedule::" + concertId + ":" + scheduleDate.toLocalDate();        // when        // 1차 조회 (DB 접근)        ConcertSchedule schedule = concertScheduleService.findConcertSchedulesByIdAndDate(concertId, scheduleDate);        // 2차 조회 (캐시 사용)        ConcertSchedule cachedSchedule = concertScheduleService.findConcertSchedulesByIdAndDate(concertId, scheduleDate);        // then        assertNotNull(schedule);        assertNotNull(cachedSchedule);        System.out.println("Redis 키 : " + cacheKey);        Boolean hasKey = redisTemplate.hasKey(cacheKey);        assertTrue(hasKey);    }```- 예약시 해당 예약 정보를 키로 생성 후에 캐싱된 키를 Junit과 redis-cli 로 확인 후, 해당 키로 결제시에 결제가 정상적으로 이루어 지는지 테스트하였다.```java @Test    void makeReservation_And_PayByCachedReservation() {        // given        Long userId = 2L;        Long concertScheduleId = 2L;        Long seatNumber = 2L;        ReservationCommand command = new ReservationCommand(userId, concertScheduleId, seatNumber);        // when (예약)        ReservationResult result = reservationFacade.makeReservation(command);        Long reservationId = result.id();        // then (예약 레디스 키 확인)        String cacheKeyPrefix = "reservation::";        String compositeKey = userId + ":" + concertScheduleId + ":" + seatNumber;        System.out.println("reservation key: " + cacheKeyPrefix + compositeKey);        Object cachedReservation = redisTemplate.opsForValue().get(cacheKeyPrefix + compositeKey);        assertThat(cachedReservation).isNotNull();        assertThat(((Reservation) cachedReservation).getId()).isEqualTo(reservationId);        // when (해당 키로 결제)        Wallet wallet = walletFacade.wallet(userId, reservationId);        // then (결제 확인)        assertThat(wallet).isNotNull();        assertThat(wallet.getUserId()).isEqualTo(userId);    }```---- 콘서트 조회시 DB 와 Cache 를 비교하여 성능 테스트를 하였다.```java@Test    void performanceConcertCache() {        // given        Long concertId = 1L;        int iterations = 100;        long dbAccessTime = 0;        long cacheAccessTime = 0;        // when         // DB 접근 시간 측정 (캐시를 비워가며 반복 테스트)        for (int i = 0; i < iterations; i++) {            // 매 반복마다 캐시 초기화            redisTemplate.getConnectionFactory().getConnection().flushAll();            long startTime = System.nanoTime();            concertService.findConcertById(concertId);            long endTime = System.nanoTime();            dbAccessTime += (endTime - startTime);        }        // when         // cache 접근 시간 측정        for (int i = 0; i < iterations; i++) {            long startTime = System.nanoTime();            concertService.findConcertById(concertId);            long endTime = System.nanoTime();            cacheAccessTime += (endTime - startTime);        }        // then        double dbAvgTime = dbAccessTime / (double) iterations / 1_000_000.0;         double cacheAvgTime = cacheAccessTime / (double) iterations / 1_000_000.0;        double speedup = dbAvgTime / cacheAvgTime;        System.out.println("===== Concert 캐시 성능 테스트 결과 =====");        System.out.println("DB 접근 평균 시간: " + dbAvgTime + " ms");        System.out.println("캐시 접근 평균 시간: " + cacheAvgTime + " ms");        System.out.println("성능 향상 비율: " + speedup + "배");        // then        assertTrue(cacheAvgTime < dbAvgTime);    }```- 멀티스레드의 경우에도 동일하게 테스트를 진행하였다.```java@Test    void multiThreadCaching_PerformanceConcertCache() throws InterruptedException {        // given        Long concertId = 1L;        int threadCount = 20;        int requestsPerThread = 50;        CountDownLatch latch = new CountDownLatch(threadCount);        AtomicLong totalTimeWithoutCache = new AtomicLong(0);        AtomicLong totalTimeWithCache = new AtomicLong(0);        // when (캐시 없이 조회)        redisTemplate.getConnectionFactory().getConnection().flushAll();        List<Thread> threadsWithoutCache = new ArrayList<>();        for (int i = 0; i < threadCount; i++) {            Thread t = new Thread(() -> {                try {                    long threadTime = 0;                    for (int j = 0; j < requestsPerThread; j++) {                        redisTemplate.getConnectionFactory().getConnection().flushAll();                        long startTime = System.nanoTime();                        concertService.findConcertById(concertId);                        long endTime = System.nanoTime();                        threadTime += (endTime - startTime);                    }                    totalTimeWithoutCache.addAndGet(threadTime);                } finally {                    latch.countDown();                }            });            threadsWithoutCache.add(t);            t.start();        }        latch.await();        // when (캐시 사용 조회)        CountDownLatch latch2 = new CountDownLatch(threadCount);        List<Thread> threadsWithCache = new ArrayList<>();        for (int i = 0; i < threadCount; i++) {            Thread t = new Thread(() -> {                try {                    long threadTime = 0;                    for (int j = 0; j < requestsPerThread; j++) {                        long startTime = System.nanoTime();                        concertService.findConcertById(concertId);                        long endTime = System.nanoTime();                        threadTime += (endTime - startTime);                    }                    totalTimeWithCache.addAndGet(threadTime);                } finally {                    latch2.countDown();                }            });            threadsWithCache.add(t);            t.start();        }        latch2.await();        // then        double avgTimeWithoutCache = totalTimeWithoutCache.get() / (double) (threadCount * requestsPerThread) / 1_000_000.0;        double avgTimeWithCache = totalTimeWithCache.get() / (double) (threadCount * requestsPerThread) / 1_000_000.0;        double speedup = avgTimeWithoutCache / avgTimeWithCache;        System.out.println("===== 캐시 성능 테스트 결과 =====");        System.out.println("스레드 수: " + threadCount + ", 스레드당 요청 수: " + requestsPerThread);        System.out.println("캐시 없이 평균 시간: " + avgTimeWithoutCache + " ms");        System.out.println("캐시 사용 평균 시간: " + avgTimeWithCache + " ms");        System.out.println("성능 향상 비율: " + speedup + "배");        // then        assertTrue(avgTimeWithCache < avgTimeWithoutCache);    }```---## 5. 활용### Redis Sorted Set (ZSet) 기반 콘서트 랭킹 시스템- 콘서트의 인기도는 보통 "얼마나 빠르게 매진되었는가", "얼마나 자주 매진되었는가"를 기준으로 판단할 수 있다고 판단하였다.- 이를 실시간으로 계산하고 효율적으로 조회하기 위해 Redis의 `Sorted Set(ZSet)` 자료구조를 활용하였다.현재, `ReservationFacade: 좌석 선점`을 하고 `PaymentFacade: 결제`를 하기 때문에 결제 성공 시점에- 해당 콘서트 스케줄의 잔여 좌석이 0인지 확인하고- 매진이라면:  - 예매 오픈 시각 조회  - 현재 시각과의 차이를 계산 (`매진 시간 - 오픈 시간`)  - Redis Sorted Set에 `ZADD`로 기록하고      ```java      ZADD concert:ranking:fastest-sold concert:101 3600      ```    - **score**: `매진시각 - 예매오픈시각` (즉, **소요 시간**)    - **value**: `concertScheduleId:<id>`  - Redis Sorted Set에 `ZSCORE`로 랭킹된 콘서트인지 판단,    - 이미 존재한다면 `ZINCRBY` 으로 누적하였다.        ```java        ZINCRBY concert:ranking:most-sold concert:101 1        ```- 그 후, 가장 빠른 매진 랭킹은 `ZRANGE` 으로 조회하였다.                        ZRANGE concert:ranking:fastest-sold 0 (limit - 1)        - 오름차순 정렬 → 매진 소요 시간이 적은 콘서트가 먼저 나옴- 통합 인기 랭킹은 `ZRANGE WITHSCORES` 으로 조회하였다. (가장 빠르게 매진된 콘서트 & 가장 자주 매진된 콘서트)            ```java    ZRANGE concert:ranking:fastest-sold 0 -1 WITHSCORES            ZRANGE concert:ranking:most-sold 0 -1 WITHSCORES    ```            - 전체 콘서트의 `"concert:<id>" → score(duration)` ,`"concert:<id>" → score(매진 횟수)` Map을 조합하여 가중치를 계산    - 소요 시간(duration)은 값이 작을수록 빠르게 매진된 것을 의미하므로 점수에 그대로 반영하고,매진 횟수(count)는 값이 클수록 인기도가 높다고 해석되므로, 가중치 계산 시 점수에 감산 방식으로 반영하여 두 지표를 동일한 방향성(점수 낮을수록 상위)으로 정규화하였다.---### Redis Sorted Set (ZSet) 기반 콘서트 대기열 시스템- 콘서트 예매 시스템은 트래픽이 집중되는 시간대에 **사용자 대기열 관리**가 필수적이다.- 이에 기존 RDB 기반의 대기열 구현을 Redis의 `Sorted Set(ZSet)` 자료구조를 활용하여 개선하였다.현재, `QueueFacade: 토큰발급 및 활성열 인입` 을 하고 있기 때문에- 유저 존재 확인- Redis `ZADD`로 `queue:active`에 userId 등록 (score = enteredAt)- Redis `HSET`으로 `queue:token:{userId}`에 token/expiredAt 저장- Redis `EXPIRE`로 5분 TTL 설정대기열 순위 확인은- `ZRANK`로 현재 userId 순위 확인- MAX_ACTIVE_COUNT 초과 시 예외 발생토큰 만료 및 활성열 → 대기열 이동은 스케줄러를 이용해- Redis `ZREM`, `DEL`로 userId 제거으로 대기열, 활성열을 관리 하게 하였다.| 명령어 | 사용 시점 | 예시 | 설명 || --- | --- | --- | --- || `ZADD` | 토큰 발급/입장 시 | `ZADD queue:active 1715818200000 42` | `userId`를 `enteredAt` 기준으로 대기열에 등록 || `ZRANK` | 순번 조회 시 | `ZRANK queue:active 42` | 해당 유저의 대기열 순서를 조회 (0-based → +1) || `ZCARD` | 현재 대기 인원 조회 | `ZCARD queue:active` | 현재 활성 대기열에 있는 인원 수 확인 || `HSET` | 토큰 저장 시 | `HSET queue:token:42 token abc123 expiredAt 2024-05-15T22:00:00` | 유저 토큰과 만료 시간 저장 || `EXPIRE` | TTL 설정 시 | `EXPIRE queue:token:42 300` | 유저 토큰 정보의 TTL을 5분으로 설정 || `ZREM` | 대기열 제거 시 | `ZREM queue:active 42` | 만료/결제 실패 등의 이유로 대기열에서 제거 || `DEL` | 토큰 삭제 시 | `DEL queue:token:42` | 유저의 토큰 데이터 제거 |