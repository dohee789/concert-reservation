# â€˜ì½˜ì„œíŠ¸ ì˜ˆì•½ ì„œë¹„ìŠ¤â€™ ì‹œë‚˜ë¦¬ì˜¤ ê¸°ë°˜## ğŸ¯ Redis ê¸°ë°˜ ìºì‹± ì „ëµ ì„±ëŠ¥ ê°œì„ ## 1. ëª©ì ëŒ€ìš©ëŸ‰ íŠ¸ë˜í”½ ìƒí™©ì—ì„œ **DB ë¶€í•˜ ë¶„ì‚°**ê³¼ **í•µì‹¬ ë°ì´í„°ì˜ ì‘ë‹µ ì†ë„ ê°œì„ **ì„ ìœ„í•´ Redisë¥¼ ë„ì…í•˜ì—¬, ìì£¼ ì¡°íšŒë˜ëŠ” **ì½˜ì„œíŠ¸/ìŠ¤ì¼€ì¤„ ì •ë³´**ì™€ **ì˜ˆì•½ ê²°ê³¼**ë¥¼ ìºì‹±í•˜ì˜€ë‹¤.## 2. Redis ìºì‹± ì „ëµ| ìºì‹± ëŒ€ìƒ | ìºì‹œ í‚¤ | ìºì‹œ ì–´ë…¸í…Œì´ì…˜ | TTL || --- | --- | --- | --- || ì½˜ì„œíŠ¸ ì¡°íšŒ | **concert::{id}** | `@Cacheable` | 5ë¶„ || ì½˜ì„œíŠ¸ ìŠ¤ì¼€ì¤„ ì¡°íšŒ | **concertSchedule::{concertId}:{yyyy-MM-dd}** | `@Cacheable` | 5ë¶„ || ì½˜ì„œíŠ¸ ì˜ˆì•½  | **reservation::{userId}:{concertScheduleId}:{seatNumber}** | `@CachePut` | 5ë¶„ || ì½˜ì„œíŠ¸ ì˜ˆì•½ ì¡°íšŒ | **reservation::{reservationId}** | `@Cacheable` | 5ë¶„ |## 3. Redis ì„¤ì •### âœ… `RedisCacheManager` ì„¤ì •```java@Beanpublic RedisCacheManager cacheManager(RedisConnectionFactory redisConnectionFactory) {    ObjectMapper objectMapper = new ObjectMapper();    objectMapper.registerModule(new JavaTimeModule()); // LocalDateTime ì§ë ¬í™” ì§€ì›    objectMapper.disable(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS); // ë‚ ì§œë¥¼ íƒ€ì„ìŠ¤íƒ¬í”„ ëŒ€ì‹  ISO-8601 í˜•ì‹ ì‚¬ìš©    objectMapper.activateDefaultTyping( // ì§ë ¬í™” ì‹œ íƒ€ì… ì •ë³´ í¬í•¨        LaissezFaireSubTypeValidator.instance,        ObjectMapper.DefaultTyping.NON_FINAL,        JsonTypeInfo.As.PROPERTY    );    GenericJackson2JsonRedisSerializer serializer = new GenericJackson2JsonRedisSerializer(objectMapper);    RedisCacheConfiguration config = RedisCacheConfiguration.defaultCacheConfig()        .entryTtl(Duration.ofMinutes(5)) // TTL: 5ë¶„        .serializeKeysWith(RedisSerializationContext.SerializationPair.fromSerializer(new StringRedisSerializer()))        .serializeValuesWith(RedisSerializationContext.SerializationPair.fromSerializer(serializer));    return RedisCacheManager.builder(redisConnectionFactory)        .cacheDefaults(config)        .build();}```### âœ… `RedisTemplate` ì„¤ì •```java@Beanpublic RedisTemplate<String, Object> redisTemplate(RedisConnectionFactory connectionFactory) {    ObjectMapper objectMapper = new ObjectMapper();    objectMapper.registerModule(new JavaTimeModule());    objectMapper.disable(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS);    objectMapper.activateDefaultTyping(        LaissezFaireSubTypeValidator.instance,        ObjectMapper.DefaultTyping.NON_FINAL,        JsonTypeInfo.As.PROPERTY    );    GenericJackson2JsonRedisSerializer serializer = new GenericJackson2JsonRedisSerializer(objectMapper);    RedisTemplate<String, Object> template = new RedisTemplate<>();    template.setConnectionFactory(connectionFactory);    template.setKeySerializer(new StringRedisSerializer());    template.setValueSerializer(serializer); // valueì— JSON ì§ë ¬í™” ì ìš©    template.setHashKeySerializer(new StringRedisSerializer());    template.setHashValueSerializer(serializer);    return template;}```- `GenericJackson2JsonRedisSerializer`: ë‹¤ì–‘í•œ í´ë˜ìŠ¤ì˜ ê°ì²´ë¥¼ Redisì— JSONìœ¼ë¡œ ì§ë ¬í™”/ì—­ì§ë ¬í™” ê°€ëŠ¥í•˜ê²Œ í•œë‹¤.- `activateDefaultTyping`: ëª¨ë“  ì§ë ¬í™”ë˜ëŠ” ê°ì²´ì— `@class` ì •ë³´ë¥¼ ìë™ìœ¼ë¡œ ë¶™ì—¬ì¤€ë‹¤.    - `@Cacheable`ì€ ìºì‹±ëœ ê°ì²´ë¥¼ ì €ì¥í•˜ê³  ë³µì›í•  ë•Œ ì§ë ¬í™”/ì—­ì§ë ¬í™”ë¥¼ ìˆ˜í–‰í•˜ëŠ”ë°, ë‹¤ì–‘í•œ ë„ë©”ì¸ ê°ì²´ë“¤ì€ ëª¨ë‘ êµ¬ì¡°ê°€ ë‹¤ë¥´ê¸°ì— ì—­ì§ë ¬í™” ì‹œ ì •í™•í•œ í´ë˜ìŠ¤ ì •ë³´ê°€ í•„ìš”    - `@JsonTypeInfo` ìœ¼ë¡œ ì§ì ‘ ëª…ì‹œ ë°©ë²•ë„ ì¡´ì¬ â†’  íƒ€ì…ì´ record ì˜ ê²½ìš°- **TTL ì„¤ì •**: 5ë¶„ í›„ ìºì‹œ ìë™ ë§Œë£Œì‹œí‚¤ê³  ìµœì‹  ë°ì´í„° ìœ ì§€í•  ìˆ˜ ìˆê²Œ í•œë‹¤.## ğŸ”„ ì§ë ¬í™”(Serialization) **ì—­ì§ë ¬í™”(Deserialization)**ë€?ê°ì²´ëŠ” ë‚´ë¶€ì ìœ¼ë¡œ ë‹¤ì–‘í•œ ê°’ê³¼ íƒ€ì…ì„ ê°€ì§€ê³  ìˆì§€ë§Œ RedisëŠ” ë‹¨ìˆœí•œ ë¬¸ìì—´ì´ë‚˜ ë°”ì´íŠ¸ë§Œ ì €ì¥í•  ìˆ˜ ìˆê¸°ì— ì´ ê°ì²´ë¥¼ Redisì— ì €ì¥í•˜ë ¤ë©´ ë¬¸ìì—´(JSON ë“±)ë¡œ ë°”ê¾¸ëŠ” ê²ƒì„ **ì§ë ¬í™”**ê·¸ ë°˜ëŒ€ë¡œ, Redisì—ì„œ ë‹¤ì‹œ ê·¸ ê°ì²´ë¥¼ êº¼ë‚¼ ë•ŒëŠ”, ì €ì¥ëœ ë¬¸ìì—´(JSON)ì„ ë‹¤ì‹œ ê°ì²´ë¡œ ë³µì›í•˜ëŠ”ê²ƒì„ **ì—­ì§ë ¬í™”**---## 4. ê¸°ëŠ¥ ë° ì„±ëŠ¥ í…ŒìŠ¤íŠ¸- ì½˜ì„œíŠ¸ ë° ì½˜ì„œíŠ¸ ìŠ¤ì¼€ì¤„ ì¡°íšŒ ìºì‹±ì˜ ê²½ìš° 1ì°¨ ì¡°íšŒ ì‹œ DBë¡œ, 2ì°¨ ì¡°íšŒ ì‹œì—ëŠ” ìºì‹œë¥¼ ì‚¬ìš©í•˜ì—¬ ìºì‹œ í‚¤ì˜ ìƒì„± ìœ ë¬´ë¥¼ Junitê³¼ redis-cli ë¡œ keyë¥¼ ì¡°íšŒí•˜ì—¬ í™•ì¸í•˜ì˜€ë‹¤.```java@Test    void canSelectCachedConcert() {        // given        Long concertId = 1L;        String cacheKey = "concert::" + concertId;        // when        // 1ì°¨ ì¡°íšŒ (DB ì ‘ê·¼)        Concert concert = concertService.findConcertById(concertId);        // 2ì°¨ ì¡°íšŒ (ìºì‹œ ì‚¬ìš©)        Concert cachedConcert = concertService.findConcertById(concertId);        // then        assertNotNull(concert);        assertNotNull(cachedConcert);        System.out.println("Redis í‚¤ :" + cacheKey);        Boolean hasKey = redisTemplate.hasKey(cacheKey);        assertTrue(hasKey);    }    @Test    void canSelectCachedConcertSchedule() {        // given        Long concertId = 1L;        LocalDateTime scheduleDate = LocalDateTime.of(2025, 5, 5, 20, 0,0);        String cacheKey = "concertSchedule::" + concertId + ":" + scheduleDate.toLocalDate();        // when        // 1ì°¨ ì¡°íšŒ (DB ì ‘ê·¼)        ConcertSchedule schedule = concertScheduleService.findConcertSchedulesByIdAndDate(concertId, scheduleDate);        // 2ì°¨ ì¡°íšŒ (ìºì‹œ ì‚¬ìš©)        ConcertSchedule cachedSchedule = concertScheduleService.findConcertSchedulesByIdAndDate(concertId, scheduleDate);        // then        assertNotNull(schedule);        assertNotNull(cachedSchedule);        System.out.println("Redis í‚¤ : " + cacheKey);        Boolean hasKey = redisTemplate.hasKey(cacheKey);        assertTrue(hasKey);    }```- ì˜ˆì•½ì‹œ í•´ë‹¹ ì˜ˆì•½ ì •ë³´ë¥¼ í‚¤ë¡œ ìƒì„± í›„ì— ìºì‹±ëœ í‚¤ë¥¼ Junitê³¼ redis-cli ë¡œ í™•ì¸ í›„, í•´ë‹¹ í‚¤ë¡œ ê²°ì œì‹œì— ê²°ì œê°€ ì •ìƒì ìœ¼ë¡œ ì´ë£¨ì–´ ì§€ëŠ”ì§€ í…ŒìŠ¤íŠ¸í•˜ì˜€ë‹¤.```java @Test    void makeReservation_And_PayByCachedReservation() {        // given        Long userId = 2L;        Long concertScheduleId = 2L;        Long seatNumber = 2L;        ReservationCommand command = new ReservationCommand(userId, concertScheduleId, seatNumber);        // when (ì˜ˆì•½)        ReservationResult result = reservationFacade.makeReservation(command);        Long reservationId = result.id();        // then (ì˜ˆì•½ ë ˆë””ìŠ¤ í‚¤ í™•ì¸)        String cacheKeyPrefix = "reservation::";        String compositeKey = userId + ":" + concertScheduleId + ":" + seatNumber;        System.out.println("reservation key: " + cacheKeyPrefix + compositeKey);        Object cachedReservation = redisTemplate.opsForValue().get(cacheKeyPrefix + compositeKey);        assertThat(cachedReservation).isNotNull();        assertThat(((Reservation) cachedReservation).getId()).isEqualTo(reservationId);        // when (í•´ë‹¹ í‚¤ë¡œ ê²°ì œ)        Wallet wallet = walletFacade.wallet(userId, reservationId);        // then (ê²°ì œ í™•ì¸)        assertThat(wallet).isNotNull();        assertThat(wallet.getUserId()).isEqualTo(userId);    }```---- ì½˜ì„œíŠ¸ ì¡°íšŒì‹œ DB ì™€ Cache ë¥¼ ë¹„êµí•˜ì—¬ ì„±ëŠ¥ í…ŒìŠ¤íŠ¸ë¥¼ í•˜ì˜€ë‹¤.```java@Test    void performanceConcertCache() {        // given        Long concertId = 1L;        int iterations = 100;        long dbAccessTime = 0;        long cacheAccessTime = 0;        // when         // DB ì ‘ê·¼ ì‹œê°„ ì¸¡ì • (ìºì‹œë¥¼ ë¹„ì›Œê°€ë©° ë°˜ë³µ í…ŒìŠ¤íŠ¸)        for (int i = 0; i < iterations; i++) {            // ë§¤ ë°˜ë³µë§ˆë‹¤ ìºì‹œ ì´ˆê¸°í™”            redisTemplate.getConnectionFactory().getConnection().flushAll();            long startTime = System.nanoTime();            concertService.findConcertById(concertId);            long endTime = System.nanoTime();            dbAccessTime += (endTime - startTime);        }        // when         // cache ì ‘ê·¼ ì‹œê°„ ì¸¡ì •        for (int i = 0; i < iterations; i++) {            long startTime = System.nanoTime();            concertService.findConcertById(concertId);            long endTime = System.nanoTime();            cacheAccessTime += (endTime - startTime);        }        // then        double dbAvgTime = dbAccessTime / (double) iterations / 1_000_000.0;         double cacheAvgTime = cacheAccessTime / (double) iterations / 1_000_000.0;        double speedup = dbAvgTime / cacheAvgTime;        System.out.println("===== Concert ìºì‹œ ì„±ëŠ¥ í…ŒìŠ¤íŠ¸ ê²°ê³¼ =====");        System.out.println("DB ì ‘ê·¼ í‰ê·  ì‹œê°„: " + dbAvgTime + " ms");        System.out.println("ìºì‹œ ì ‘ê·¼ í‰ê·  ì‹œê°„: " + cacheAvgTime + " ms");        System.out.println("ì„±ëŠ¥ í–¥ìƒ ë¹„ìœ¨: " + speedup + "ë°°");        // then        assertTrue(cacheAvgTime < dbAvgTime);    }```- ë©€í‹°ìŠ¤ë ˆë“œì˜ ê²½ìš°ì—ë„ ë™ì¼í•˜ê²Œ í…ŒìŠ¤íŠ¸ë¥¼ ì§„í–‰í•˜ì˜€ë‹¤.```java@Test    void multiThreadCaching_PerformanceConcertCache() throws InterruptedException {        // given        Long concertId = 1L;        int threadCount = 20;        int requestsPerThread = 50;        CountDownLatch latch = new CountDownLatch(threadCount);        AtomicLong totalTimeWithoutCache = new AtomicLong(0);        AtomicLong totalTimeWithCache = new AtomicLong(0);        // when (ìºì‹œ ì—†ì´ ì¡°íšŒ)        redisTemplate.getConnectionFactory().getConnection().flushAll();        List<Thread> threadsWithoutCache = new ArrayList<>();        for (int i = 0; i < threadCount; i++) {            Thread t = new Thread(() -> {                try {                    long threadTime = 0;                    for (int j = 0; j < requestsPerThread; j++) {                        redisTemplate.getConnectionFactory().getConnection().flushAll();                        long startTime = System.nanoTime();                        concertService.findConcertById(concertId);                        long endTime = System.nanoTime();                        threadTime += (endTime - startTime);                    }                    totalTimeWithoutCache.addAndGet(threadTime);                } finally {                    latch.countDown();                }            });            threadsWithoutCache.add(t);            t.start();        }        latch.await();        // when (ìºì‹œ ì‚¬ìš© ì¡°íšŒ)        CountDownLatch latch2 = new CountDownLatch(threadCount);        List<Thread> threadsWithCache = new ArrayList<>();        for (int i = 0; i < threadCount; i++) {            Thread t = new Thread(() -> {                try {                    long threadTime = 0;                    for (int j = 0; j < requestsPerThread; j++) {                        long startTime = System.nanoTime();                        concertService.findConcertById(concertId);                        long endTime = System.nanoTime();                        threadTime += (endTime - startTime);                    }                    totalTimeWithCache.addAndGet(threadTime);                } finally {                    latch2.countDown();                }            });            threadsWithCache.add(t);            t.start();        }        latch2.await();        // then        double avgTimeWithoutCache = totalTimeWithoutCache.get() / (double) (threadCount * requestsPerThread) / 1_000_000.0;        double avgTimeWithCache = totalTimeWithCache.get() / (double) (threadCount * requestsPerThread) / 1_000_000.0;        double speedup = avgTimeWithoutCache / avgTimeWithCache;        System.out.println("===== ìºì‹œ ì„±ëŠ¥ í…ŒìŠ¤íŠ¸ ê²°ê³¼ =====");        System.out.println("ìŠ¤ë ˆë“œ ìˆ˜: " + threadCount + ", ìŠ¤ë ˆë“œë‹¹ ìš”ì²­ ìˆ˜: " + requestsPerThread);        System.out.println("ìºì‹œ ì—†ì´ í‰ê·  ì‹œê°„: " + avgTimeWithoutCache + " ms");        System.out.println("ìºì‹œ ì‚¬ìš© í‰ê·  ì‹œê°„: " + avgTimeWithCache + " ms");        System.out.println("ì„±ëŠ¥ í–¥ìƒ ë¹„ìœ¨: " + speedup + "ë°°");        // then        assertTrue(avgTimeWithCache < avgTimeWithoutCache);    }```---## 5. í™œìš©### Redis Sorted Set (ZSet) ê¸°ë°˜ ì½˜ì„œíŠ¸ ë­í‚¹ ì‹œìŠ¤í…œ- ì½˜ì„œíŠ¸ì˜ ì¸ê¸°ë„ëŠ” ë³´í†µ "ì–¼ë§ˆë‚˜ ë¹ ë¥´ê²Œ ë§¤ì§„ë˜ì—ˆëŠ”ê°€", "ì–¼ë§ˆë‚˜ ìì£¼ ë§¤ì§„ë˜ì—ˆëŠ”ê°€"ë¥¼ ê¸°ì¤€ìœ¼ë¡œ íŒë‹¨í•  ìˆ˜ ìˆë‹¤ê³  íŒë‹¨í•˜ì˜€ë‹¤.- ì´ë¥¼ ì‹¤ì‹œê°„ìœ¼ë¡œ ê³„ì‚°í•˜ê³  íš¨ìœ¨ì ìœ¼ë¡œ ì¡°íšŒí•˜ê¸° ìœ„í•´ Redisì˜ `Sorted Set(ZSet)` ìë£Œêµ¬ì¡°ë¥¼ í™œìš©í•˜ì˜€ë‹¤.í˜„ì¬, `ReservationFacade: ì¢Œì„ ì„ ì `ì„ í•˜ê³  `PaymentFacade: ê²°ì œ`ë¥¼ í•˜ê¸° ë•Œë¬¸ì— ê²°ì œ ì„±ê³µ ì‹œì ì—- í•´ë‹¹ ì½˜ì„œíŠ¸ ìŠ¤ì¼€ì¤„ì˜ ì”ì—¬ ì¢Œì„ì´ 0ì¸ì§€ í™•ì¸í•˜ê³ - ë§¤ì§„ì´ë¼ë©´:  - ì˜ˆë§¤ ì˜¤í”ˆ ì‹œê° ì¡°íšŒ  - í˜„ì¬ ì‹œê°ê³¼ì˜ ì°¨ì´ë¥¼ ê³„ì‚° (`ë§¤ì§„ ì‹œê°„ - ì˜¤í”ˆ ì‹œê°„`)  - Redis Sorted Setì— `ZADD`ë¡œ ê¸°ë¡í•˜ê³       ```java      ZADD concert:ranking:fastest-sold concert:101 3600      ```    - **score**: `ë§¤ì§„ì‹œê° - ì˜ˆë§¤ì˜¤í”ˆì‹œê°` (ì¦‰, **ì†Œìš” ì‹œê°„**)    - **value**: `concertScheduleId:<id>`  - Redis Sorted Setì— `ZSCORE`ë¡œ ë­í‚¹ëœ ì½˜ì„œíŠ¸ì¸ì§€ íŒë‹¨,    - ì´ë¯¸ ì¡´ì¬í•œë‹¤ë©´ `ZINCRBY` ìœ¼ë¡œ ëˆ„ì í•˜ì˜€ë‹¤.        ```java        ZINCRBY concert:ranking:most-sold concert:101 1        ```- ê·¸ í›„, ê°€ì¥ ë¹ ë¥¸ ë§¤ì§„ ë­í‚¹ì€ `ZRANGE` ìœ¼ë¡œ ì¡°íšŒí•˜ì˜€ë‹¤.                        ZRANGE concert:ranking:fastest-sold 0 (limit - 1)        - ì˜¤ë¦„ì°¨ìˆœ ì •ë ¬ â†’ ë§¤ì§„ ì†Œìš” ì‹œê°„ì´ ì ì€ ì½˜ì„œíŠ¸ê°€ ë¨¼ì € ë‚˜ì˜´- í†µí•© ì¸ê¸° ë­í‚¹ì€ `ZRANGE WITHSCORES` ìœ¼ë¡œ ì¡°íšŒí•˜ì˜€ë‹¤. (ê°€ì¥ ë¹ ë¥´ê²Œ ë§¤ì§„ëœ ì½˜ì„œíŠ¸ & ê°€ì¥ ìì£¼ ë§¤ì§„ëœ ì½˜ì„œíŠ¸)            ```java    ZRANGE concert:ranking:fastest-sold 0 -1 WITHSCORES            ZRANGE concert:ranking:most-sold 0 -1 WITHSCORES    ```            - ì „ì²´ ì½˜ì„œíŠ¸ì˜ `"concert:<id>" â†’ score(duration)` ,`"concert:<id>" â†’ score(ë§¤ì§„ íšŸìˆ˜)` Mapì„ ì¡°í•©í•˜ì—¬ ê°€ì¤‘ì¹˜ë¥¼ ê³„ì‚°    - ì†Œìš” ì‹œê°„(duration)ì€ ê°’ì´ ì‘ì„ìˆ˜ë¡ ë¹ ë¥´ê²Œ ë§¤ì§„ëœ ê²ƒì„ ì˜ë¯¸í•˜ë¯€ë¡œ ì ìˆ˜ì— ê·¸ëŒ€ë¡œ ë°˜ì˜í•˜ê³ ,ë§¤ì§„ íšŸìˆ˜(count)ëŠ” ê°’ì´ í´ìˆ˜ë¡ ì¸ê¸°ë„ê°€ ë†’ë‹¤ê³  í•´ì„ë˜ë¯€ë¡œ, ê°€ì¤‘ì¹˜ ê³„ì‚° ì‹œ ì ìˆ˜ì— ê°ì‚° ë°©ì‹ìœ¼ë¡œ ë°˜ì˜í•˜ì—¬ ë‘ ì§€í‘œë¥¼ ë™ì¼í•œ ë°©í–¥ì„±(ì ìˆ˜ ë‚®ì„ìˆ˜ë¡ ìƒìœ„)ìœ¼ë¡œ ì •ê·œí™”í•˜ì˜€ë‹¤.---### Redis Sorted Set (ZSet) ê¸°ë°˜ ì½˜ì„œíŠ¸ ëŒ€ê¸°ì—´ ì‹œìŠ¤í…œ- ì½˜ì„œíŠ¸ ì˜ˆë§¤ ì‹œìŠ¤í…œì€ íŠ¸ë˜í”½ì´ ì§‘ì¤‘ë˜ëŠ” ì‹œê°„ëŒ€ì— **ì‚¬ìš©ì ëŒ€ê¸°ì—´ ê´€ë¦¬**ê°€ í•„ìˆ˜ì ì´ë‹¤.- ì´ì— ê¸°ì¡´ RDB ê¸°ë°˜ì˜ ëŒ€ê¸°ì—´ êµ¬í˜„ì„ Redisì˜ `Sorted Set(ZSet)` ìë£Œêµ¬ì¡°ë¥¼ í™œìš©í•˜ì—¬ ê°œì„ í•˜ì˜€ë‹¤.í˜„ì¬, `QueueFacade: í† í°ë°œê¸‰ ë° í™œì„±ì—´ ì¸ì…` ì„ í•˜ê³  ìˆê¸° ë•Œë¬¸ì—- ìœ ì € ì¡´ì¬ í™•ì¸- Redis `ZADD`ë¡œ `queue:active`ì— userId ë“±ë¡ (score = enteredAt)- Redis `HSET`ìœ¼ë¡œ `queue:token:{userId}`ì— token/expiredAt ì €ì¥- Redis `EXPIRE`ë¡œ 5ë¶„ TTL ì„¤ì •ëŒ€ê¸°ì—´ ìˆœìœ„ í™•ì¸ì€- `ZRANK`ë¡œ í˜„ì¬ userId ìˆœìœ„ í™•ì¸- MAX_ACTIVE_COUNT ì´ˆê³¼ ì‹œ ì˜ˆì™¸ ë°œìƒí† í° ë§Œë£Œ ë° í™œì„±ì—´ â†’ ëŒ€ê¸°ì—´ ì´ë™ì€ ìŠ¤ì¼€ì¤„ëŸ¬ë¥¼ ì´ìš©í•´- Redis `ZREM`, `DEL`ë¡œ userId ì œê±°ìœ¼ë¡œ ëŒ€ê¸°ì—´, í™œì„±ì—´ì„ ê´€ë¦¬ í•˜ê²Œ í•˜ì˜€ë‹¤.| ëª…ë ¹ì–´ | ì‚¬ìš© ì‹œì  | ì˜ˆì‹œ | ì„¤ëª… || --- | --- | --- | --- || `ZADD` | í† í° ë°œê¸‰/ì…ì¥ ì‹œ | `ZADD queue:active 1715818200000 42` | `userId`ë¥¼ `enteredAt` ê¸°ì¤€ìœ¼ë¡œ ëŒ€ê¸°ì—´ì— ë“±ë¡ || `ZRANK` | ìˆœë²ˆ ì¡°íšŒ ì‹œ | `ZRANK queue:active 42` | í•´ë‹¹ ìœ ì €ì˜ ëŒ€ê¸°ì—´ ìˆœì„œë¥¼ ì¡°íšŒ (0-based â†’ +1) || `ZCARD` | í˜„ì¬ ëŒ€ê¸° ì¸ì› ì¡°íšŒ | `ZCARD queue:active` | í˜„ì¬ í™œì„± ëŒ€ê¸°ì—´ì— ìˆëŠ” ì¸ì› ìˆ˜ í™•ì¸ || `HSET` | í† í° ì €ì¥ ì‹œ | `HSET queue:token:42 token abc123 expiredAt 2024-05-15T22:00:00` | ìœ ì € í† í°ê³¼ ë§Œë£Œ ì‹œê°„ ì €ì¥ || `EXPIRE` | TTL ì„¤ì • ì‹œ | `EXPIRE queue:token:42 300` | ìœ ì € í† í° ì •ë³´ì˜ TTLì„ 5ë¶„ìœ¼ë¡œ ì„¤ì • || `ZREM` | ëŒ€ê¸°ì—´ ì œê±° ì‹œ | `ZREM queue:active 42` | ë§Œë£Œ/ê²°ì œ ì‹¤íŒ¨ ë“±ì˜ ì´ìœ ë¡œ ëŒ€ê¸°ì—´ì—ì„œ ì œê±° || `DEL` | í† í° ì‚­ì œ ì‹œ | `DEL queue:token:42` | ìœ ì €ì˜ í† í° ë°ì´í„° ì œê±° |